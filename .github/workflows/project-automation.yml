name: "Project Automation"
on:
  issues:
    types: [opened, closed, labeled, unlabeled, assigned, unassigned]
  pull_request:
    types: [opened, closed, ready_for_review]
  create:

jobs:
  project_automation:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      projects: write
    steps:
      - name: Generate App Token
        id: app_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.PROJECT_APP_ID }}
          private-key: ${{ secrets.PROJECT_APP_KEY }}

      - name: Auto-assign new issues to project
        if: github.event_name == 'issues' && github.event.action == 'opened'
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          echo "Adding issue #${{ github.event.issue.number }} to project"
          
          # Add to project board using GraphQL API
          gh api graphql -f query='
            mutation($project: ID!, $issue: ID!) {
              addProjectV2ItemById(input: {projectId: $project, contentId: $issue}) {
                item { 
                  id 
                  fieldValues(first: 20) {
                    nodes {
                      ... on ProjectV2ItemFieldSingleSelectValue {
                        name
                        field {
                          ... on ProjectV2SingleSelectField {
                            name
                          }
                        }
                      }
                    }
                  }
                }
              }
            }' -f project="${{ vars.PROJECT_ID }}" -f issue="${{ github.event.issue.node_id }}"

      - name: Set initial status for new issues
        if: github.event_name == 'issues' && github.event.action == 'opened'
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          echo "Setting initial status to Backlog"
          
          # Get the project item ID first
          ITEM_ID=$(gh api graphql -f query='
            query($project: ID!) {
              node(id: $project) {
                ... on ProjectV2 {
                  items(first: 100) {
                    nodes {
                      id
                      content {
                        ... on Issue {
                          number
                        }
                      }
                    }
                  }
                }
              }
            }' -f project="${{ vars.PROJECT_ID }}" \
            --jq ".data.node.items.nodes[] | select(.content.number == ${{ github.event.issue.number }}) | .id")
          
          # Set status to "Backlog"
          if [ ! -z "$ITEM_ID" ]; then
            gh api graphql -f query='
              mutation($project: ID!, $item: ID!, $field: ID!, $value: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $project, 
                  itemId: $item, 
                  fieldId: $field, 
                  value: {singleSelectOptionId: $value}
                }) { 
                  projectV2Item { id } 
                }
              }' -f project="${{ vars.PROJECT_ID }}" \
                 -f item="$ITEM_ID" \
                 -f field="${{ vars.STATUS_FIELD_ID }}" \
                 -f value="${{ vars.BACKLOG_OPTION_ID }}"
          fi

      - name: Move to Dev Complete on PR merge
        if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          echo "PR #${{ github.event.pull_request.number }} merged, updating related issues"
          
          # Extract issue number from PR body or title
          ISSUE_NUMBER=""
          
          # Check PR body for "Closes #123" patterns
          if [[ "${{ github.event.pull_request.body }}" =~ [Cc]loses[[:space:]]+#([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          elif [[ "${{ github.event.pull_request.body }}" =~ [Ff]ixes[[:space:]]+#([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          elif [[ "${{ github.event.pull_request.body }}" =~ [Rr]esolves[[:space:]]+#([0-9]+) ]]; then
            ISSUE_NUMBER="${BASH_REMATCH[1]}"
          fi
          
          if [ ! -z "$ISSUE_NUMBER" ]; then
            echo "Found linked issue #$ISSUE_NUMBER"
            
            # Get the project item ID for the issue
            ITEM_ID=$(gh api graphql -f query='
              query($project: ID!) {
                node(id: $project) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      nodes {
                        id
                        content {
                          ... on Issue {
                            number
                          }
                        }
                      }
                    }
                  }
                }
              }' -f project="${{ vars.PROJECT_ID }}" \
              --jq ".data.node.items.nodes[] | select(.content.number == $ISSUE_NUMBER) | .id")
            
            if [ ! -z "$ITEM_ID" ]; then
              # Update issue status to "Dev Complete"
              gh api graphql -f query='
                mutation($project: ID!, $item: ID!, $field: ID!, $value: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $project, 
                    itemId: $item, 
                    fieldId: $field, 
                    value: {singleSelectOptionId: $value}
                  }) { 
                    projectV2Item { id } 
                  }
                }' -f project="${{ vars.PROJECT_ID }}" \
                   -f item="$ITEM_ID" \
                   -f field="${{ vars.STATUS_FIELD_ID }}" \
                   -f value="${{ vars.DEV_COMPLETE_OPTION_ID }}"
              
              # Assign to QA if QA_ASSIGNEE is set
              if [ ! -z "${{ vars.QA_ASSIGNEE }}" ]; then
                gh issue edit $ISSUE_NUMBER --add-assignee "${{ vars.QA_ASSIGNEE }}"
                echo "Assigned issue #$ISSUE_NUMBER to QA: ${{ vars.QA_ASSIGNEE }}"
              fi
              
              # Send QA notification email
              if [ ! -z "${{ vars.QA_EMAIL }}" ] && [ ! -z "${{ secrets.SENDGRID_API_KEY }}" ]; then
                echo "Sending QA notification email for issue #$ISSUE_NUMBER"
                
                # Get issue details for email
                ISSUE_DETAILS=$(gh api repos/${{ github.repository }}/issues/$ISSUE_NUMBER --jq '{
                  number: .number,
                  title: .title,
                  body: .body,
                  assignees: [.assignees[].login],
                  labels: [.labels[].name],
                  html_url: .html_url
                }')
                
                # Get PR details
                PR_DETAILS=$(gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }} --jq '{
                  number: .number,
                  title: .title,
                  html_url: .html_url,
                  user: .user.login,
                  merged_at: .merged_at
                }')
                
                # Create email content using AI
                cat > /tmp/qa_email_generator.js << 'JSEOF'
const fs = require('fs');
const https = require('https');

const issueDetails = JSON.parse(process.env.ISSUE_DETAILS);
const prDetails = JSON.parse(process.env.PR_DETAILS);
const today = new Date().toLocaleDateString('en-US', { 
  weekday: 'long', 
  year: 'numeric', 
  month: 'long', 
  day: 'numeric' 
});

const prompt = `Generate a professional QA notification email for a development ticket that's ready for testing.

Issue Details:
${JSON.stringify(issueDetails, null, 2)}

Pull Request Details:
${JSON.stringify(prDetails, null, 2)}

Create an email that:
1. Has a clear, actionable subject line
2. Provides context about what was developed
3. Includes testing requirements if available in the issue body
4. Has links to both the issue and merged PR
5. Is professional and helpful for the QA team

Return in format:
SUBJECT: [subject line]
BODY: [email body in HTML format]`;

const data = JSON.stringify({
  model: "gpt-4.1",
  messages: [
    {
      role: "system",
      content: "You are a helpful assistant that generates professional QA notification emails. Focus on providing clear context and actionable information for testing."
    },
    {
      role: "user", 
      content: prompt
    }
  ],
  max_tokens: 800,
  temperature: 0.5
});

const options = {
  hostname: 'api.openai.com',
  port: 443,
  path: '/v1/chat/completions',
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
    'Content-Length': Buffer.byteLength(data)
  }
};

const req = https.request(options, (res) => {
  let responseData = '';
  
  res.on('data', (chunk) => {
    responseData += chunk;
  });
  
  res.on('end', () => {
    try {
      const response = JSON.parse(responseData);
      const emailContent = response.choices[0].message.content;
      
      const subjectMatch = emailContent.match(/SUBJECT:\s*(.*?)(?:\n|$)/);
      const bodyMatch = emailContent.match(/BODY:\s*([\s\S]*?)$/);
      
      const subject = subjectMatch ? subjectMatch[1].trim() : `Ready for QA: Issue #${issueDetails.number} - ${issueDetails.title}`;
      const body = bodyMatch ? bodyMatch[1].trim() : emailContent;
      
      fs.writeFileSync('/tmp/qa_email_subject.txt', subject);
      fs.writeFileSync('/tmp/qa_email_body.html', body);
      
      console.log('QA email content generated successfully!');
    } catch (error) {
      console.error('Error generating QA email:', error);
      
      // Fallback email
      const fallbackSubject = `Ready for QA: Issue #${issueDetails.number} - ${issueDetails.title}`;
      const fallbackBody = `
      <h2>Ready for QA Testing</h2>
      <p><strong>Issue #${issueDetails.number}:</strong> <a href="${issueDetails.html_url}">${issueDetails.title}</a></p>
      <p><strong>Merged PR:</strong> <a href="${prDetails.html_url}">#${prDetails.number} - ${prDetails.title}</a></p>
      <p><strong>Developer:</strong> ${prDetails.user}</p>
      <p><strong>Priority:</strong> ${issueDetails.labels.filter(l => l.startsWith('priority:')).join(', ') || 'Normal'}</p>
      <p>This ticket has been completed and is ready for testing. Please review the issue description and acceptance criteria.</p>
      `;
      
      fs.writeFileSync('/tmp/qa_email_subject.txt', fallbackSubject);
      fs.writeFileSync('/tmp/qa_email_body.html', fallbackBody);
    }
  });
});

req.on('error', (error) => {
  console.error('Error calling OpenAI API:', error);
  process.exit(1);
});

req.write(data);
req.end();
JSEOF

                # Generate email content
                ISSUE_DETAILS="$ISSUE_DETAILS" PR_DETAILS="$PR_DETAILS" OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" node /tmp/qa_email_generator.js
                
                # Send email via SendGrid
                QA_SUBJECT=$(cat /tmp/qa_email_subject.txt)
                QA_BODY=$(cat /tmp/qa_email_body.html)
                
                cat > /tmp/qa_sendgrid_payload.json << JSONEOF
{
  "personalizations": [
    {
      "to": [
        {
          "email": "${{ vars.QA_EMAIL }}"
        }
      ]
    }
  ],
  "from": {
    "email": "${{ vars.FROM_EMAIL || 'noreply@github.com' }}",
    "name": "${{ vars.FROM_NAME || 'Development Team' }}"
  },
  "subject": $(echo "$QA_SUBJECT" | jq -Rs .),
  "content": [
    {
      "type": "text/html",
      "value": $(echo "$QA_BODY" | jq -Rs .)
    }
  ]
}
JSONEOF

                curl -X "POST" \
                  "https://api.sendgrid.com/v3/mail/send" \
                  -H "Authorization: Bearer ${{ secrets.SENDGRID_API_KEY }}" \
                  -H "Content-Type: application/json" \
                  -d @/tmp/qa_sendgrid_payload.json
                
                if [ $? -eq 0 ]; then
                  echo "✅ QA notification email sent successfully!"
                else
                  echo "❌ Failed to send QA notification email"
                fi
              fi
            fi
          else
            echo "No linked issue found in PR body"
          fi

      - name: Update priority based on labels
        if: github.event_name == 'issues' && (github.event.action == 'labeled' || github.event.action == 'unlabeled')
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          echo "Checking for priority label changes"
          
          # Get current labels
          LABELS=$(gh api repos/${{ github.repository }}/issues/${{ github.event.issue.number }} --jq '.labels[].name')
          
          PRIORITY=""
          if echo "$LABELS" | grep -q "priority:critical"; then
            PRIORITY="${{ vars.CRITICAL_PRIORITY_ID }}"
          elif echo "$LABELS" | grep -q "priority:high"; then
            PRIORITY="${{ vars.HIGH_PRIORITY_ID }}"
          elif echo "$LABELS" | grep -q "priority:medium"; then
            PRIORITY="${{ vars.MEDIUM_PRIORITY_ID }}"
          elif echo "$LABELS" | grep -q "priority:low"; then
            PRIORITY="${{ vars.LOW_PRIORITY_ID }}"
          fi
          
          if [ ! -z "$PRIORITY" ]; then
            # Get the project item ID
            ITEM_ID=$(gh api graphql -f query='
              query($project: ID!) {
                node(id: $project) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      nodes {
                        id
                        content {
                          ... on Issue {
                            number
                          }
                        }
                      }
                    }
                  }
                }
              }' -f project="${{ vars.PROJECT_ID }}" \
              --jq ".data.node.items.nodes[] | select(.content.number == ${{ github.event.issue.number }}) | .id")
            
            if [ ! -z "$ITEM_ID" ]; then
              # Update priority field
              gh api graphql -f query='
                mutation($project: ID!, $item: ID!, $field: ID!, $value: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $project, 
                    itemId: $item, 
                    fieldId: $field, 
                    value: {singleSelectOptionId: $value}
                  }) { 
                    projectV2Item { id } 
                  }
                }' -f project="${{ vars.PROJECT_ID }}" \
                   -f item="$ITEM_ID" \
                   -f field="${{ vars.PRIORITY_FIELD_ID }}" \
                   -f value="$PRIORITY"
            fi
          fi

      - name: Move to In Progress on branch creation
        if: github.event_name == 'create' && github.event.ref_type == 'branch'
        env:
          GH_TOKEN: ${{ steps.app_token.outputs.token }}
        run: |
          BRANCH_NAME="${{ github.event.ref }}"
          echo "Branch '$BRANCH_NAME' was created"
          
          # Extract issue number from branch name following Git Flow convention
          ISSUE_NUMBER=""
          if [[ "$BRANCH_NAME" == feature/issue-* ]] || [[ "$BRANCH_NAME" == bugfix/issue-* ]] || [[ "$BRANCH_NAME" == hotfix/issue-* ]]; then
            ISSUE_NUMBER=$(echo "$BRANCH_NAME" | sed -n 's/.*issue-\([0-9]\+\).*/\1/p')
            echo "Detected issue number: #$ISSUE_NUMBER from branch naming pattern"
          elif [[ "$BRANCH_NAME" =~ issue-[0-9]+ ]]; then
            ISSUE_NUMBER=$(echo "$BRANCH_NAME" | sed -n 's/.*issue-\([0-9]\+\).*/\1/p')
            echo "Detected issue number: #$ISSUE_NUMBER from branch name"
          fi
          
          if [ ! -z "$ISSUE_NUMBER" ]; then
            echo "Moving issue #$ISSUE_NUMBER to 'In Progress' status"
            
            # Check if issue exists
            if ! gh issue view $ISSUE_NUMBER >/dev/null 2>&1; then
              echo "Issue #$ISSUE_NUMBER not found, skipping"
              exit 0
            fi
            
            # Get the project item ID for the issue
            ITEM_ID=$(gh api graphql -f query='
              query($project: ID!) {
                node(id: $project) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      nodes {
                        id
                        content {
                          ... on Issue {
                            number
                          }
                        }
                      }
                    }
                  }
                }
              }' -f project="${{ vars.PROJECT_ID }}" \
              --jq ".data.node.items.nodes[] | select(.content.number == $ISSUE_NUMBER) | .id")
            
            if [ ! -z "$ITEM_ID" ]; then
              # Update issue status to "In Progress"
              gh api graphql -f query='
                mutation($project: ID!, $item: ID!, $field: ID!, $value: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $project, 
                    itemId: $item, 
                    fieldId: $field, 
                    value: {singleSelectOptionId: $value}
                  }) { 
                    projectV2Item { id } 
                  }
                }' -f project="${{ vars.PROJECT_ID }}" \
                   -f item="$ITEM_ID" \
                   -f field="${{ vars.STATUS_FIELD_ID }}" \
                   -f value="${{ vars.IN_PROGRESS_OPTION_ID }}"
              
              echo "✅ Successfully moved issue #$ISSUE_NUMBER to 'In Progress' status"
            else
              echo "Could not find project item for issue #$ISSUE_NUMBER"
            fi
          else
            echo "No issue number detected in branch name '$BRANCH_NAME'"
            echo "Expected format: feature/issue-123-description or bugfix/issue-123-description"
          fi